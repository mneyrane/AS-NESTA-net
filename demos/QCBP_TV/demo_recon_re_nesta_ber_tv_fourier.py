"""
Demo for reconstructing an image from subsampled Fourier measurements
under the Bernoulli model.

Here a restarted NESTA-like algorithm solves an analysis QCBP problem
where the analysis operator is the discrete gradient (or TV) operator.

In this code, the measurements are generated by sampling frequencies 
using two Bernoulli masks, one corresponding to uniform sampling and
the other variable density sampling. As a result, a frequency can be
possibly (and at most) twice.

-- Maksym Neyra-Nesterenko
-- mneyrane@sfu.ca
"""
import math
import torch
import numpy as np
import operators as op
import nn
from PIL import Image

with Image.open("../demo_images/test_image.png") as im:
    im.save('demo_restarted_nesta_tv_reconstruction-truth-image.png')
    X = np.asarray(im).astype(float) / 255

assert X.shape[0] == X.shape[1]

# parameters
eta = 1e-9             # - noise level
N, _ = X.shape       # - image size (assumed to be N by N)
m = math.ceil(0.5*N*N) # - expected num of measurements per mask
inner_iters = 12        # - number of NESTA iterations
outer_iters = 10        # - number of restarts
mu0 = 1e-2              # - initial smoothing parameter
delta = 1e-12           # - ?
r = 0.5                 # - smoothing decay factor


# generate sampling mask
# - i.e. each mask is a zero-one matrix with same shape as the image
# - can also load in a sampling mask from data or an image

# -- NOTE --
# In this experiment, the masks are generated with respect to the
# Bernoulli model. The exact number of measurements need not be m.

ber_opt_probs = op.bernoulli_opt_sampling_probs_2d(N,m)

uniform_mask = np.random.rand(N,N) < m/N**2
variable_mask = np.random.binomial(np.ones((N,N), dtype=int), ber_opt_probs)

#n_mask = mask.numpy()
#(Image.fromarray(n_mask)).save('demo_restarted_nesta_tv_reconstruction-mask.png')

uniform_idxs = np.nonzero(uniform_mask.transpose())
variable_idxs = np.nonzero(variable_mask.transpose())

uniform_mask_t = torch.from_numpy(uniform_mask)
variable_mask_t = torch.from_numpy(variable_mask)
uniform_idxs_t = uniform_mask_t.transpose(0,1).nonzero(as_tuple=True)
variable_idxs_t = variable_mask_t.transpose(0,1).nonzero(as_tuple=True)

m1 = len(uniform_idxs[0])
m2 = len(variable_idxs[0])

# display some info

print('Image size (number of pixels):', N*N)
print('Exact number of measurements:', m1+m2)
print('Bernoulli model parameter m =', m)
print('Effective sample rate:', (m1+m2)/(2*N*N))

# define measurement vector
noise = (eta/math.sqrt(m1+m2))*torch.randn(m1+m2)
vec_X = torch.from_numpy(np.reshape(X.transpose(),N*N))
u1 = op.fourier_2d(vec_X,1,N,uniform_idxs_t)*N/math.sqrt(m) + noise[:m1]
u2 = op.fourier_2d(vec_X,1,N,variable_idxs_t)*N/math.sqrt(m) + noise[m1:m1+m2]

uniform_idxs_1d = np.ravel_multi_index(uniform_idxs, (N,N))
variable_idxs_1d = np.ravel_multi_index(variable_idxs, (N,N))

omega2diff1 = np.setdiff1d(variable_idxs_1d,uniform_idxs_1d) 
omega1 = np.concatenate((uniform_idxs_1d, omega2diff1))
u2_mask = np.isin(variable_idxs_1d, omega2diff1, assume_unique=True)
y1 = torch.cat((u1, u2[u2_mask]))

omega1diff2 = np.setdiff1d(uniform_idxs_1d,variable_idxs_1d)
omega2 = np.concatenate((variable_idxs_1d, omega1diff2))
u1_mask = np.isin(uniform_idxs_1d, omega1diff2, assume_unique=True)
y2 = torch.cat((u2, u1[u1_mask]))

perm1 = np.argsort(omega1)
perm2 = np.argsort(omega2)

y1 = y1[perm1]
y2 = y2[perm2]
o1 = omega1[perm1]
o2 = omega2[perm2]

# -- DEBUG --
assert (o1 == o2).all(), "Incorrectly implemented frequency sample stacking"

sample_idxs_1d = o1

sample_idxs = np.unravel_index(sample_idxs_1d, (N,N))

sample_idxs_t = tuple([torch.from_numpy(a) for a in sample_idxs])

mask_t = torch.zeros((N,N), dtype=bool)
mask_t[sample_idxs_t] = True

# generate functions for measurement and analysis operators

# measurement operator (subsampled Fourier transform)
subsampled_ft = lambda x, mode: op.fourier_2d(x,mode,N,mask_t)*(N/math.sqrt(m))

# discrete gradient (TV) operator
discrete_grad = lambda x, mode: op.discrete_gradient_2d(x,mode,N,N)
L_grad = 2.0 # - Lipschitz constant of discrete_grad

# perform image reconstruction
z0 = torch.zeros(N*N,dtype=y1.dtype)

x_final, iterates = nn.restarted_nesta_bernoulli_wqcbp(
        y1, y2, z0,
        subsampled_ft, discrete_grad, L_grad,
        inner_iters, outer_iters,
        eta, mu0, delta, r, False)

X_rec = np.transpose(np.reshape(np.real(x_final.numpy()),(N,N)))
im_rec_array = np.clip((X_rec*255),0,255).astype('uint8')

print('abs error:', np.linalg.norm(np.abs(X_rec - X), ord='fro'))

Image.fromarray(im_rec_array).save('demo_restarted_nesta_tv_reconstruction-reconstructed-image.png')

